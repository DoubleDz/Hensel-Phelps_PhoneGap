// Generated by CoffeeScript 1.4.0
(function() {
  var Drop, DropOSDialog, DropRetry, ProgressSample2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  DropOSDialog = (function() {

    function DropOSDialog(file_input_obj, prid, foid, cb_class, accept) {
      var file;
      this.file_input_obj = file_input_obj;
      this.prid = prid;
      this.foid = foid;
      this.cb_class = cb_class;
      this.drop = new Drop(this.prid, false, this.cb_class, accept);
      this.files = this.file_input_obj.files;
      this.file_list = (function() {
        var _i, _len, _ref, _results;
        _ref = this.files;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          _results.push({
            file: file,
            parent_id: this.foid
          });
        }
        return _results;
      }).call(this);
    }

    DropOSDialog.prototype.fileHandler = function() {
      return this.drop.fileHandler(this.file_list);
    };

    return DropOSDialog;

  })();

  window.EpicMvc.Extras.DropOSDialog = DropOSDialog;

  DropRetry = (function() {

    function DropRetry(file_list, prid, cb_class) {
      this.file_list = file_list;
      this.prid = prid;
      this.cb_class = cb_class;
      this.drop = new Drop(this.prid, false, this.cb_class);
      this.drop.fileHandler(this.file_list);
    }

    return DropRetry;

  })();

  window.EpicMvc.Extras.DropRetry = DropRetry;

  Drop = (function() {

    function Drop(prid, parent_foid, cb_class, accept, drop_type) {
      var f;
      this.prid = prid;
      this.parent_foid = parent_foid;
      this.cb_class = cb_class;
      this.drop_type = drop_type;
      this._StepWhileUploadFiles = __bind(this._StepWhileUploadFiles, this);

      this._StepUploadFolders = __bind(this._StepUploadFolders, this);

      f = 'E:Drop.constructor';
      _log(f, 'prid/parent_foid/accept', this.prid, this.parent_foid, accept, this.drop_type);
      this.cbo = new this.cb_class(this, this.prid);
      this.cb = this.cbo.progress;
      this.rest = window.EpicMvc.Extras.Rest;
      this.cancel = false;
      this.old_cb = this.cb;
      this.step_types = ['START', 'COUNT_ENTRIES', 'COUNT_BYTES', 'UPLOAD_FOLDERS', 'UPLOAD_FILES', 'FINISH'];
      this.step_before_confirm = 'COUNT_BYTES';
      this.step = 0;
      this.counters = {
        total_folders: 0,
        total_files: 0,
        total_bytes: 0,
        folders: 0,
        files: 0,
        bytes: 0,
        pending: 0,
        total_percent: '0%'
      };
      this.final = [];
      this.final_dirs = [];
      this.final_files = {};
      this.folder_ids = [];
      this.last_ix = this.final_dirs.length;
      this.top_list = [];
      this.top_files = [];
      this.step_count_progress_called = false;
      this.step_upload_folders_called = false;
      this.progress_last_data = false;
      this.uploads_active = 0;
      this.uploads_todo_list = [];
      this.uploads_xhr = {};
      this.accept = accept != null ? accept : [];
    }

    Drop.prototype._cancel = function() {
      var ix, xhr, _ref;
      this.cancel = true;
      this.cb = function() {};
      _ref = this.uploads_xhr;
      for (ix in _ref) {
        xhr = _ref[ix];
        xhr.abort();
      }
    };

    Drop.prototype._unique = function() {
      return window.EpicMvc.Epic.nextCounter();
    };

    Drop.prototype.Cancel = function() {
      return this._cancel();
    };

    Drop.prototype.fileHandler = function(file_list_with_parent_ids) {
      var f, ix, key, keys, rec, _i, _len, _ref;
      f = 'E:Drop.fileHandler';
      _log(f, file_list_with_parent_ids);
      if (!this._Progress('START')) {
        return;
      }
      for (ix = _i = 0, _len = file_list_with_parent_ids.length; _i < _len; ix = ++_i) {
        rec = file_list_with_parent_ids[ix];
        if (this.accept.length && (this.accept.indexOf((rec.file.name.split('.')).pop().toLowerCase())) === -1) {
          continue;
        }
        this.final_files[ix] = [rec.file];
        this.folder_ids.push(rec.parent_id);
      }
      keys = (function() {
        var _results;
        _results = [];
        for (key in this.final_files) {
          _results.push(key);
        }
        return _results;
      }).call(this);
      if (keys.length === 0) {
        this.cb('CANCEL_EMPTY', null, null, {
          accept: this.accept
        });
        this._cancel();
        return false;
      }
      if (!this._Progress('COUNT_BYTES')) {
        return;
      }
      this.counters.total_files = this.counters.pending = keys.length;
      _ref = this.final_files;
      for (ix in _ref) {
        rec = _ref[ix];
        this.counters.total_bytes += rec[0].size + 1;
      }
      return this._StepCountComplete();
    };

    Drop.prototype.dropHandler = function(evt) {
      var entry, f, i, items, new_items, rec, _i, _ref;
      f = 'E:Drop.dropHandler';
      _log(f, "@parent_foid", this.parent_foid);
      if (this.parent_foid === false) {
        this.parent_foid = $(evt.target).attr('data-folder');
        _log(f, "from target, @parent_foid", this.parent_foid);
      }
      items = (function() {
        var _i, _len, _ref, _results;
        _ref = evt.dataTransfer.items;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          rec = _ref[_i];
          if (rec.kind === 'file') {
            _results.push(rec);
          }
        }
        return _results;
      })();
      new_items = [];
      for (i = _i = 0, _ref = items.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        entry = items[i].webkitGetAsEntry();
        if (this.accept.length && entry.isDirectory) {
          continue;
        }
        if (this.accept.length && (this.accept.indexOf((entry.name.split('.')).pop().toLowerCase())) === -1) {
          continue;
        }
        new_items.push(items[i]);
      }
      if (this.drop_type && this.drop_type.type === 'version') {
        if (new_items.length !== 1 || new_items[0].webkitGetAsEntry().isDirectory) {
          this.cb('CANCEL_EMPTY', null, null, {
            accept: this.accept
          });
          this._cancel();
          return false;
        }
      }
      if (new_items.length === 0) {
        this.cb('CANCEL_EMPTY', null, null, {
          accept: this.accept
        });
        this._cancel();
        return false;
      }
      this.handleFiles(items);
      return true;
    };

    Drop.prototype.handleFiles = function(top_items) {
      var entry, f, i, _i, _ref,
        _this = this;
      this.top_items = top_items;
      f = 'E:Drop.handleFiles';
      _log2(f, this.top_items.length, this.top_items);
      if (!this._Progress('START')) {
        return;
      }
      for (i = _i = 0, _ref = this.top_items.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        entry = this.top_items[i].webkitGetAsEntry();
        _log3(f, 'TOP entry #', i, entry);
        if (entry.isDirectory) {
          this.top_list.push(entry);
        } else {
          this.counters.total_files += 1;
          (function(entry) {
            _log3(f, 'TOP entry.file');
            return entry.file(function(file) {
              _log3(f, 'file', file, _this);
              _this.top_files.push(file);
              _this.counters.pending += 1;
              return _this.counters.total_bytes += file.size + 1;
            }, function(err) {
              _log(f, 'ERROR, entry.file()', err);
              return _this.counters.total_files -= 1;
            });
          })(entry);
        }
      }
      this._Populate(this.top_list, this.last_ix);
      return this._AddMoreDirs();
    };

    Drop.prototype._AddMoreDirs = function() {
      var f, ix, last_entry, start_ix, _fn, _i, _ref,
        _this = this;
      f = 'E:Drop._AddMoreDirs';
      _log2(f, {
        last_ix: this.last_ix,
        fol: this.final_dirs.length
      });
      if (this.last_ix >= this.final_dirs.length) {
        _log2(f, {
          last_ix: this.last_ix,
          f_len: this.final.length,
          fo_len: this.final_dirs.length,
          final: this.final
        });
        this._StepCountComplete();
        return;
      }
      start_ix = this.last_ix;
      this.last_ix = this.final_dirs.length;
      _fn = function(ix, last_entry) {
        return _this.final_dirs[ix].createReader().readEntries(function(list) {
          _this._Populate(list, ix + 1);
          if (last_entry) {
            _this._AddMoreDirs();
          }
        });
      };
      for (ix = _i = start_ix, _ref = this.last_ix; start_ix <= _ref ? _i < _ref : _i > _ref; ix = start_ix <= _ref ? ++_i : --_i) {
        last_entry = ix === this.last_ix - 1;
        _fn(ix, last_entry);
      }
    };

    Drop.prototype._Populate = function(list, ix) {
      var entry, f, file_list, i, _i, _ref,
        _this = this;
      f = 'E:Drop._Populate';
      _log2(f, {
        len: list.length,
        ix: ix
      });
      this._Progress('COUNT_ENTRIES', 'ASYNC');
      file_list = [];
      this.final_files[ix - 1] = file_list;
      for (i = _i = 0, _ref = list.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        entry = list[i];
        if (entry.isDirectory) {
          this.final.push({
            ix: ix,
            name: entry.name
          });
          this.final_dirs.push(entry);
          this.counters.total_folders += 1;
        } else {
          this.counters.total_files += 1;
          (function(entry, file_list) {
            return entry.file(function(file) {
              _log3(f, 'inside file', _this, _this.counters);
              file_list.push(file);
              _this.counters.pending += 1;
              return _this.counters.total_bytes += file.size + 1;
            }, function(err) {
              _log(f, 'ERROR, entry.file', err);
              return _this.counters.total_files -= 1;
            });
          })(entry, file_list);
        }
      }
    };

    Drop.prototype._StepCountComplete = function(trys) {
      var f,
        _this = this;
      f = 'E:Drop._StepCountComplete';
      _log2(f, trys);
      if (!this.step_count_progress_called) {
        this.step_count_progress_called = true;
        if (!this._Progress('COUNT_BYTES')) {
          return;
        }
      }
      trys = trys ? trys + 1 : 1;
      if (trys > 10) {
        alert("Unable to 'stat' file sizes. (" + this.counters.pending + "/" + this.counters.total_files + ")");
        this.cb('CANCEL_ABORT');
        this._cancel();
        return;
      }
      if (this.counters.total_files > this.counters.pending) {
        return setTimeout((function() {
          if (!_this.cancel) {
            return _this._StepCountComplete(trys);
          }
        }), 500);
      }
      return this._StepConfirm();
    };

    Drop.prototype._StepConfirm = function(after) {
      var _this = this;
      if (!after) {
        return setTimeout((function() {
          if (!_this.cancel) {
            return _this._StepConfirm(true);
          }
        }), 150);
      }
      if (this.counters.total_folders + this.counters.total_files === 0) {
        this.cb('CANCEL_EMPTY', null, null, {
          accept: this.accept
        });
        this._cancel();
        return;
      }
      if (!this._Progress('CONFIRM')) {

      }
    };

    Drop.prototype._StepUploadFolders = function(confirm) {
      var f, keep_going, response;
      f = 'E:Drop._StepUploadFolders';
      if (this.step_upload_folders_called) {
        return;
      }
      this.step_upload_folders_called = true;
      if (!confirm) {
        return;
      }
      if (!this._Progress('UPLOAD_FOLDERS')) {
        return;
      }
      if (this.counters.total_folders === 0) {
        return this._StepUploadFiles();
      }
      response = this.rest.post('Project/' + this.prid + '/Folder/' + this.parent_foid + '/folders', f, {
        folder_list: JSON.stringify(this.final)
      });
      _log2(f, response);
      if (!response.folder_ids) {
        this.cb('RESPONSE', this.counters, true, {
          subevent: 'FOLDERS_ERROR',
          response: response
        });
        this.cb('CANCEL_ABORT');
        this._cancel();
        return;
      }
      this.folder_ids = response.folder_ids;
      this.counters.folders = this.counters.total_folders;
      keep_going = this.cb('RESPONSE', this.counters, true, {
        subevent: 'FOLDERS',
        parent_foid: this.parent_foid,
        response: response,
        folders_info: this.final
      });
      if (!keep_going) {
        this._cancel();
        return;
      }
      return this._StepUploadFiles();
    };

    Drop.prototype._StepUploadFiles = function() {
      var f, file, _i, _len, _ref;
      f = 'E:Drop._StepUploadFiles';
      _log(f, this.top_files, {
        fol: this.final_dirs,
        fil: this.folder_ids.length
      });
      if (!this._Progress('UPLOAD_FILES')) {
        return;
      }
      _ref = this.top_files;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        this._UploadFile(this.parent_foid, file);
      }
      if (this.folder_ids.length === 0) {
        return this._StepWhileUploadFiles();
      }
      return this._StepUploadFilesNotTop();
    };

    Drop.prototype._StepUploadFilesNotTop = function() {
      var file, i, parent_id, _i, _j, _len, _ref, _ref1;
      for (i = _i = 0, _ref = this.folder_ids.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        parent_id = this.folder_ids[i];
        _ref1 = this.final_files[i];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          file = _ref1[_j];
          this._UploadFile(parent_id, file);
        }
      }
      return this._StepWhileUploadFiles();
    };

    Drop.prototype._UploadFile = function(parent_id, file) {
      var f, handle, reported_bytes,
        _this = this;
      if (this.cancel) {
        return;
      }
      if (this.uploads_active > 2) {
        this.uploads_todo_list.push([parent_id, file]);
        return;
      }
      handle = 'xhr_upload_file_' + this._unique();
      f = 'E:Drop._UploadFile:' + handle;
      this.uploads_active += 1;
      reported_bytes = 0;
      return this.uploads_xhr[handle] = this.rest.upload_file(this.prid, parent_id, file, this.drop_type, function(event, p1, p2) {
        var bytes, done, perc, todo_file, todo_parent_id, _ref;
        if (_this.cancel) {
          return;
        }
        done = false;
        switch (event) {
          case 'start':
            _this.cb('ONE_FILE', _this.counters, false, {
              subevent: 'START',
              handle: handle,
              file: file,
              parent_id: parent_id,
              sofar: 0,
              total: file.size,
              as_percent: '0%'
            });
            break;
          case 'fail':
            _this.cb('RESPONSE', _this.counters, true, {
              subevent: 'FILE_ERROR',
              handle: handle,
              file: file,
              parent_id: parent_id,
              response: p1
            });
            done = true;
            break;
          case 'success':
            _this.cb('RESPONSE', _this.counters, true, {
              subevent: 'FILE',
              handle: handle,
              file: file,
              parent_id: parent_id,
              response: p1
            });
            done = true;
            break;
          case 'progress':
            bytes = p1 - reported_bytes;
            _this.counters.bytes += bytes;
            reported_bytes += bytes;
            perc = Math.floor((p1 / p2) * 100) + '%';
            _this.counters.total_percent = Math.floor((_this.counters.bytes / _this.counters.total_bytes) * 100) + '%';
            _this.cb('ONE_FILE', _this.counters, false, {
              subevent: 'PROGRESS',
              handle: handle,
              file: file,
              parent_id: parent_id,
              sofar: p1,
              total: p2,
              as_percent: perc
            });
        }
        if (done) {
          delete _this.uploads_xhr[handle];
          _this.uploads_active -= 1;
          _this.counters.files += 1;
          _this.counters.bytes += file.size + 1 - reported_bytes;
          _this.counters.total_percent = Math.floor((_this.counters.bytes / _this.counters.total_bytes) * 100) + '%';
          _this.cb('ONE_FILE', _this.counters, true, {
            subevent: 'END',
            handle: handle,
            file: file,
            parent_id: parent_id,
            sofar: file.size,
            total: file.size,
            as_percent: '100%'
          });
          if (_this.counters.files === _this.counters.total_files) {
            _this._StepFinish();
          }
          if (_this.uploads_todo_list.length) {
            _ref = _this.uploads_todo_list.shift(0), todo_parent_id = _ref[0], todo_file = _ref[1];
            return _this._UploadFile(todo_parent_id, todo_file);
          }
        }
      });
    };

    Drop.prototype._StepWhileUploadFiles = function(again) {
      var _this = this;
      if (this.counters.total_files === 0) {
        return this._StepFinish();
      }
      if (this.counters.files < this.counters.total_files) {
        this._Progress('UPLOAD_FILES');
        return setTimeout((function() {
          if (!_this.cancel) {
            return _this._StepWhileUploadFiles(again);
          }
        }), 500);
      }
    };

    Drop.prototype._StepFinish = function(after) {
      var msg,
        _this = this;
      if (!after) {
        return setTimeout((function() {
          if (!_this.cancel) {
            return _this._StepFinish(true);
          }
        }), 10);
      }
      if (!this._Progress('FINISH')) {
        return;
      }
      msg = '(DEFAULT MESSAGE) Uploaded ';
      msg += this.counters.total_folders ? "" + this.counters.folders + " of " + this.counters.total_folders + " folders " : '';
      msg += this.counters.total_files ? ("" + this.counters.files + " of " + this.counters.total_files + " files ") + ("totaling " + this.counters.bytes + " of " + this.counters.total_bytes + " bytes") : '';
      msg += '!';
      return alert(msg);
    };

    Drop.prototype._Progress = function(step_name, subevent, data) {
      var f, new_step, step;
      f = 'E:Drop._Progress:' + step_name;
      step = this.step_types.indexOf((step_name === 'CONFIRM' ? this.step_before_confirm : step_name));
      if (step === -1) {
        alert(f + ' Unknown step_name');
      }
      new_step = this.step < step;
      while (this.step < step) {
        if (!this.cb(this.step_types[this.step], this.counters, true)) {
          this._cancel();
          return false;
        }
        this.step += 1;
      }
      if (step_name === 'CONFIRM') {
        this.cb('CONFIRM', this.counters, true, this._StepUploadFolders);
        return true;
      }
      if (!this.cb(this.step_types[this.step], this.counters, false)) {
        this._cancel();
        return false;
      }
      return true;
    };

    return Drop;

  })();

  window.EpicMvc.Extras.Drop = Drop;

  ProgressSample2 = (function() {

    function ProgressSample2(loader, project_id) {
      this.loader = loader;
      this.project_id = project_id;
      this.progress = __bind(this.progress, this);

      this.stopped = false;
      this.model_folders = window.EpicMvc.Epic.getInstance('Directory');
      this.model_uploads = window.EpicMvc.Epic.getInstance('Uploads');
      this.model_id = this.model_uploads.newUpload(this, this.project_id);
      this.did_confirm = false;
    }

    ProgressSample2.prototype.Cancel = function() {
      this.loader.Cancel();
      return this.stopped = true;
    };

    ProgressSample2.prototype._stop = function(msg, no_click) {
      if (this.stopped) {
        return;
      }
      this.stopped = true;
      if (msg) {
        alert(msg);
      }
      if (no_click !== true) {
        window.EpicMvc.Epic.makeClick(false, 'cancel_progress', {
          id: this.model_id
        }, true);
      }
      this.model_uploads.uploadAbort(this.model_id);
      return false;
    };

    ProgressSample2.prototype.progress = function(step, cnt, last_flag, extra_data) {
      var answer, f, ff_limit, fol_limit, msg, stats, _ref;
      f = 'E:ProgressSample2.progress';
      if (step !== "UPLOAD_FILES" && step !== "ONE_FILE") {
        _log2(f, step, {
          last: last_flag,
          did: this.did_confirm,
          extra_data: extra_data
        });
      }
      switch (step) {
        case 'START':
          if (last_flag) {
            this.model_uploads.uploadProgress(this.model_id, cnt);
            this.stopped = false;
          }
          break;
        case 'CANCEL':
        case 'CANCEL_ABORT':
          return this._stop(step);
        case 'CANCEL_EMPTY':
          if ((_ref = extra_data.accept) != null ? _ref.length : void 0) {
            msg = 'No files found of type: ' + extra_data.accept.join('/');
          } else {
            msg = 'No files or folders found.';
          }
          return this._stop(msg, (this.did_confirm ? false : true));
        case 'RESPONSE':
          if (extra_data.subevent === 'FOLDERS_ERROR') {
            return this._stop('Error on server, uploading folder structure.');
          } else if (extra_data.subevent === 'FOLDERS') {
            this.model_folders.foldersUploaded(this.model_id, this.project_id, extra_data.parent_foid, extra_data.response.folder_ids, extra_data.folders_info);
          } else if (extra_data.subevent === 'FILE' || extra_data.subevent === 'FILE_ERROR') {
            this.model_uploads.fileResponse(this.model_id, extra_data.handle, $.extend({}, extra_data.response));
            this.model_folders.fileResponse(this.model_id, extra_data.handle, $.extend({}, extra_data.response));
          }
          break;
        case 'CONFIRM':
          if (this.did_confirm) {
            return true;
          }
          this.did_confirm = true;
          stats = $.extend({}, cnt, {
            step: step,
            last: (last_flag ? 'yes' : '')
          });
          this.model_uploads.uploadProgress(this.model_id, stats);
          this.model_uploads.replyCallback(this.model_id, extra_data);
          if (false) {
            ff_limit = 20000;
            fol_limit = 500;
            msg = [];
            if (cnt.total_files + cnt.total_folders > ff_limit) {
              msg.push("" + ff_limit + " files+folders");
            }
            if (cnt.total_folders > fol_limit) {
              msg.push("" + fol_limit + " folders");
            }
            if (msg.length) {
              return this._stop("Exceded max of " + (msg.join('and')) + (" [Folder count: " + cnt.total_folders + "] [File count: " + cnt.total_files + "]"));
            }
            answer = this._confirm(cnt);
            if (answer) {
              return true;
            }
            return this._stop();
          }
          return true;
      }
      switch (step) {
        case 'ONE_FILE':
          this.model_uploads.fileProgress(this.model_id, extra_data.handle, $.extend({}, extra_data, {
            name: extra_data.file.name
          }));
          this.model_folders.fileProgress(this.model_id, extra_data.handle, $.extend({}, extra_data, {
            name: extra_data.file.name,
            project_id: this.project_id
          }));
          break;
        default:
          if (step === 'FINISH' || step.match(/^(UPLOAD|COUNT)_/)) {
            stats = $.extend({}, cnt, {
              step: step,
              last: (last_flag ? 'yes' : '')
            });
            this.model_uploads.uploadProgress(this.model_id, stats);
          }
      }
      return step !== 'FINISH';
    };

    ProgressSample2.prototype._confirm = function(cnt) {
      var question;
      question = 'Upload ';
      question += (cnt.total_folders ? "" + cnt.total_folders + " folders " : '');
      question += cnt.total_files ? "" + cnt.total_files + " files, total " + cnt.total_bytes + " bytes" : '';
      question += '?';
      return confirm(question);
    };

    return ProgressSample2;

  })();

  window.EpicMvc.Extras.ProgressSample2 = ProgressSample2;

}).call(this);
