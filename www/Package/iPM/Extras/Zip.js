// Generated by CoffeeScript 1.4.0
(function() {
  var Zip, ZipProgress,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Zip = (function() {

    function Zip(prid, parent_foid) {
      var f;
      this.prid = prid;
      this.parent_foid = parent_foid;
      this._StepWhileXferFiles = __bind(this._StepWhileXferFiles, this);

      this._StepXferFiles = __bind(this._StepXferFiles, this);

      this._StepPrepareTempFs = __bind(this._StepPrepareTempFs, this);

      this._DoWhile = __bind(this._DoWhile, this);

      this._DoList = __bind(this._DoList, this);

      f = 'E:Zip.constructor';
      _log(f, 'prid/parent_foid', this.prid, this.parent_foid);
      this.zu = window.EpicMvc.Extras.ZipUtil;
      this.rest = window.EpicMvc.Extras.Rest;
      this.cancel = false;
      this.step_types = ['START', 'DOWNLOAD_FILES', 'ASSEMBLE', 'FINISH'];
      this.step = 0;
      this.counters = {
        total_files: 0,
        total_bytes: 1,
        folders: 0,
        files: 0,
        bytes: 0,
        pending: 0
      };
      this.file_list = [];
      this.folder_list = [];
      this.xfers_allow_active = 3;
      this.xfers_active = 0;
      this.xfers_todo_list = [];
      this.xfers_xhr = {};
      this.xfers_complete = {};
      this.crc_todo = [];
      this.zipname = 'somename.zip';
      this.blob_size = 1 * 1024 * 1024;
    }

    Zip.prototype._Cancel = function(reason) {
      var ix, xhr, _ref;
      if (reason) {
        alert(reason);
      }
      if (this.cancel === true) {
        return;
      }
      this.cancel = true;
      this.cbo.Cancel();
      this.cb = function() {};
      _ref = this.xfers_xhr;
      for (ix in _ref) {
        xhr = _ref[ix];
        xhr.abort();
      }
    };

    Zip.prototype._Unique = function() {
      return window.EpicMvc.Epic.nextCounter();
    };

    Zip.prototype._DoList = function(list, cb_each_e, cbe_final) {
      var doOneE, offset,
        _this = this;
      offset = -1;
      doOneE = function(err) {
        offset++;
        if (err !== null || offset >= list.length) {
          return cbe_final(err);
        } else {
          return cb_each_e(list[offset], doOneE);
        }
      };
      return doOneE(null);
    };

    Zip.prototype._DoWhile = function(cb_while_e, cbe_final) {
      var doOneE,
        _this = this;
      doOneE = function(err, again) {
        if (err !== null || !again) {
          return cbe_final(err);
        } else {
          return cb_while_e(doOneE);
        }
      };
      return doOneE(null, true);
    };

    Zip.prototype.Cancel = function() {
      return this._Cancel();
    };

    Zip.prototype.Start = function(files, folders, project_name, cbo, download_dir, active_download_dirs, download_prefix, include_versions) {
      var f, ix, rec, _ref;
      this.cbo = cbo;
      this.download_dir = download_dir;
      this.active_download_dirs = active_download_dirs;
      f = 'E:Zip.Start';
      _log(f, 'files[0]/folders[0]/@prid/@parent_foid', files[0], folders[0], this.prid, this.parent_foid);
      this.prefix_pat = new RegExp("^" + download_prefix + ".*");
      this.cb = this.cbo.progress;
      this.old_cb = this.cb;
      if (!this._Progress('START')) {
        return;
      }
      this.zipname = (this.parent_foid === 0 ? project_name : folders[this.parent_foid].name) + '.zip';
      this.zipname = this.zipname.replace(/[\/:*?"><|\\]/, '-');
      this.include_versions = include_versions;
      this._snapFileFolder(files, folders);
      this.counters.total_files = this.counters.pending = this.file_list.length;
      _ref = this.file_list;
      for (ix in _ref) {
        rec = _ref[ix];
        this.counters.total_bytes += rec.size;
      }
      return this._StepPrepareTempFs(this._StepXferFiles);
    };

    Zip.prototype._snapFileFolder = function(files, folders) {
      var addFiles, child_files, child_folders, f, id, rec, _name, _name1, _ref, _ref1,
        _this = this;
      f = 'E:Zip._snapFileFolder';
      child_folders = {};
      for (id in folders) {
        rec = folders[id];
        if (!(id > 0)) {
          continue;
        }
        if ((_ref = child_folders[_name = rec.folder_id]) == null) {
          child_folders[_name] = [];
        }
        child_folders[rec.folder_id].push(id);
      }
      _log(f, 'child_folders', child_folders);
      child_files = {};
      for (id in files) {
        rec = files[id];
        if (rec.type === 1 && !(rec.file_id in files)) {
          continue;
        }
        if ((_ref1 = child_files[_name1 = rec.folder_id]) == null) {
          child_files[_name1] = [];
        }
        child_files[rec.folder_id].push(id);
      }
      addFiles = function(foid, parent_path) {
        var annot_path, content_file, content_filename, path, rec_name, v_ix, version_path, _i, _j, _len, _len1, _ref2, _ref3, _results;
        path = parent_path + folders[foid].name + '/';
        _this.folder_list.push({
          path: path,
          modified: folders[foid].modified
        });
        if (foid in child_files) {
          _ref2 = child_files[foid];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            id = _ref2[_i];
            rec = files[id];
            content_file = rec.type === 0 ? rec : files[rec.file_id];
            content_filename = content_file.name;
            version_path = '';
            if (_this.include_versions && !content_file.latest) {
              v_ix = content_file.v_ix + '';
              version_path = content_file.name + ' - versions/';
              content_filename = '00'.substring(0, 2 - v_ix.length) + v_ix + '-' + content_file.version_name;
            }
            annot_path = rec.type === 0 ? '' : content_filename + ' - annotations/';
            rec_name = rec.type === 0 ? content_filename : rec.name;
            _this.file_list.push({
              md5: rec.md5,
              path: path + version_path + annot_path,
              name: rec_name,
              size: Number(rec.size),
              id: id,
              modified: rec.modified
            });
          }
        }
        if (foid in child_folders) {
          _ref3 = child_folders[foid];
          _results = [];
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            id = _ref3[_j];
            _results.push(addFiles(id, path));
          }
          return _results;
        }
      };
      return addFiles(this.parent_foid, '');
    };

    Zip.prototype._StepPrepareTempFs = function(cb) {
      var FsCheckSpace, FsGetRootDir, FsGetTempDir, FsGetZipWriter, FsReadDirs, FsRmDir, GetFs, IsErr, f, old_dirs,
        _this = this;
      f = 'E:Zip._StepPrepareTempFs';
      _log(f);
      this.tempFs = false;
      this.tempFsRootDir = false;
      this.tempFsDirEntry = false;
      this.tempFsZipEntry = false;
      this.tempFsZipWriter = false;
      IsErr = function(err, who) {
        var extra;
        _log2('IsErr', who, err);
        if (err === null) {
          return false;
        }
        _log2(who, 'ERROR', err);
        extra = err.name === 'SecurityError' ? 'Are you in Incognito mode?' : err.message;
        _this._Cancel("'Prepare Filesystem' error. (" + extra + ")");
        return true;
      };
      GetFs = function(cbe) {
        var ff;
        ff = f + ':GetFsE';
        webkitRequestFileSystem(TEMPORARY, 0, function(fs) {
          _log2(ff, 'got fs', fs);
          _this.tempFs = fs;
          return cbe(null);
        }, function(err) {
          return cbe(err);
        });
      };
      FsGetRootDir = function(cbe) {
        var ff;
        ff = f + ':FsGetRootDir';
        _log2(ff);
        _this.tempFsRootDir = _this.tempFs.root.createReader();
        _log2(ff, 'got rootDir', _this.tempFsRootDir);
        cbe(null);
      };
      old_dirs = [];
      FsReadDirs = function(cbe) {
        var ff;
        ff = f + ':FsReadDirs';
        _log2(ff);
        _this.tempFsRootDir.readEntries(function(entries) {
          var dir, _i, _len;
          _log2(ff, 'got readEntries', entries);
          if (entries.length > 0) {
            for (_i = 0, _len = entries.length; _i < _len; _i++) {
              dir = entries[_i];
              if ((_this.prefix_pat.test(dir.name)) && (_this.active_download_dirs.indexOf(dir.name)) === -1) {
                old_dirs.push(dir);
              }
            }
            return cbe(null, true);
          } else {
            return cbe(null, false);
          }
        }, function(err) {
          return cbe(err);
        });
      };
      FsRmDir = function(dir, cbe) {
        var ff;
        ff = f + ':FsRmDir';
        _log2(ff, dir);
        dir.removeRecursively((function() {
          return cbe(null);
        }), function(err) {
          return cbe(err);
        });
      };
      FsCheckSpace = function(cbe) {
        var ff;
        ff = f + ':FsCheckSpace';
        _log2(ff);
        navigator.webkitTemporaryStorage.queryUsageAndQuota(function(used, remaining) {
          var need;
          need = _this.counters.total_bytes * 2 + (1 * 1024 * 1024);
          _log(ff, 'used/remaining', used, remaining);
          if (remaining < need) {
            alert("Not enough space in the Temp Filesystem " + ("(used=" + used + ", remaining=" + remaining + ", need=" + need + ", short=" + (need - remaining)));
            return cbe('Not enough space.');
          }
          return cbe(null);
        }, function(err) {
          return cbe(err);
        });
      };
      FsGetTempDir = function(cbe) {
        var ff;
        ff = f + ':FsGetTempDir';
        _log2(ff);
        _this.tempFs.root.getDirectory(_this.download_dir, {
          create: true
        }, function(entry) {
          _log2(ff, 'got dir entry', entry);
          _this.tempFsDirEntry = entry;
          return cbe(null);
        }, function(err) {
          return cbe(err);
        });
      };
      FsGetZipWriter = function(cbe) {
        var ff;
        ff = f + ':FsGetZipWriter';
        _log2(ff);
        _this.tempFsDirEntry.getFile(_this.zipname, {
          create: true
        }, function(entry) {
          _this.tempFsZipEntry = entry;
          return entry.createWriter(function(writer) {
            _log2(ff, 'got writer', writer);
            _this.tempFsZipWriter = writer;
            return cbe(null);
          }, function(err) {
            return cbe(err);
          });
        }, function(err) {
          return cbe(err, function(err) {
            return cbe(err);
          });
        });
      };
      return GetFs(function(err) {
        if (IsErr(err, f)) {
          return false;
        }
        return FsGetRootDir(function(err) {
          if (IsErr(err, f)) {
            return false;
          }
          return _this._DoWhile(FsReadDirs, function(err) {
            var rec;
            if (IsErr(err, f)) {
              return false;
            }
            _log(f, 'old_dirs', (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = old_dirs.length; _i < _len; _i++) {
                rec = old_dirs[_i];
                _results.push(rec.name);
              }
              return _results;
            })());
            return _this._DoList(old_dirs, FsRmDir, function(err) {
              if (IsErr(err, f)) {
                return false;
              }
              return FsCheckSpace(function(err) {
                if (IsErr(err, f)) {
                  return false;
                }
                return FsGetTempDir(function(err) {
                  if (IsErr(err, f)) {
                    return false;
                  }
                  return FsGetZipWriter(function(err) {
                    if (IsErr(err, f)) {
                      return false;
                    }
                    cb();
                  });
                });
              });
            });
          });
        });
      });
    };

    Zip.prototype._StepXferFiles = function() {
      var f, rec, _i, _len, _ref;
      f = 'E:Zip._StepXferFiles';
      if (this.file_list.length === 0) {
        return this._StepAfterXfer();
      }
      _ref = this.file_list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rec = _ref[_i];
        this._xferFile(rec);
      }
      return this._StepWhileXferFiles();
    };

    Zip.prototype._xferFile = function(file_rec) {
      var DoneFile, FsGetFileWriter, FsWriteFile, IsErr, StartFile, entry, f, md5, reported_bytes, writer,
        _this = this;
      entry = writer = false;
      if (this.cancel) {
        return;
      }
      if (this.xfers_active >= this.xfers_allow_active) {
        this.xfers_todo_list.push([file_rec]);
        return;
      }
      md5 = file_rec.md5;
      f = 'E:Zip._xferFile:' + md5;
      _log2(f);
      reported_bytes = 0;
      DoneFile = function(was_active, reason) {
        var todo_file;
        if (was_active) {
          if (!(md5 in _this.xfers_xhr)) {
            _this._Cancel('Zip download issue #901-xhr');
            return false;
          }
          delete _this.xfers_xhr[md5];
          delete _this.xfers_complete[md5].blob;
          delete _this.xfers_complete[md5].writer;
          if (reason !== 'success') {
            delete _this.xfers_complete[md5];
          }
          _this.xfers_active -= 1;
        }
        _this.counters.files += 1;
        _this.counters.bytes += file_rec.size - reported_bytes;
        _this.cb('ONE_FILE', _this.counters, true, {
          subevent: 'END',
          handle: md5,
          file: file_rec,
          sofar: file_rec.size,
          total: file_rec.size
        });
        if (_this.counters.files === _this.counters.total_files) {
          return _this._StepAfterXfer();
        }
        if (_this.xfers_active < _this.xfers_allow_active) {
          if (_this.xfers_todo_list.length) {
            todo_file = _this.xfers_todo_list.shift(0)[0];
            return setTimeout((function() {
              return _this._xferFile(todo_file);
            }), 0);
          }
        }
      };
      if (md5 in this.xfers_complete) {
        DoneFile(false, 'dup');
        return;
      }
      this.xfers_complete[md5] = false;
      this.xfers_active += 1;
      FsGetFileWriter = function(cbe) {
        var ff;
        ff = f + ':FsGetFileWriter';
        return _this.tempFsDirEntry.getFile(md5, {
          create: true
        }, function(entry) {
          return entry.createWriter(function(writer) {
            _log2(ff, 'got file md5/entry/writer', md5, entry, writer);
            return cbe(null, entry, writer);
          }, function(err) {
            return cbe(err);
          });
        }, function(err) {
          return cbe(err, function(err) {
            return cbe(err);
          });
        });
      };
      FsWriteFile = function(writer, blob, cbe) {
        writer.onwriteend = function() {
          return cbe(null);
        };
        writer.onerror = function(err) {
          return cbe(err);
        };
        return writer.write(blob);
      };
      StartFile = function(entry, writer, cb_md5) {
        var response, url;
        response = _this.rest.rest("/Project/" + _this.prid + "/File/" + file_rec.id + "/inline", f);
        if (!('signed_url' in response)) {
          _this.cb('RESPONSE', _this.counters, true, {
            subevent: 'FILE_ERROR',
            handle: md5,
            file: file_rec,
            response: response
          });
          alert('No signed_url ' + md5);
          cb_md5(md5);
          return;
        }
        url = response.signed_url;
        return _this.xfers_xhr[md5] = _this.rest.download_file(url, function(event, p1, p2) {
          var bytes, done;
          if (_this.cancel) {
            return;
          }
          done = false;
          switch (event) {
            case 'start':
              _this.cb('ONE_FILE', _this.counters, false, {
                subevent: 'START',
                handle: md5,
                file: file_rec,
                sofar: 0,
                total: file_rec.size
              });
              break;
            case 'fail':
              _this.cb('RESPONSE', _this.counters, true, {
                subevent: 'FILE_ERROR',
                handle: md5,
                file: file_rec,
                response: p1
              });
              done = true;
              break;
            case 'success':
              _this.cb('RESPONSE', _this.counters, true, {
                subevent: 'FILE',
                handle: md5,
                file: file_rec
              });
              done = true;
              break;
            case 'progress':
              bytes = p1 - reported_bytes;
              _this.counters.bytes += bytes;
              reported_bytes += bytes;
              _this.cb('ONE_FILE', _this.counters, false, {
                subevent: 'PROGRESS',
                handle: md5,
                file: file_rec,
                sofar: p1,
                total: p2
              });
          }
          if (done) {
            _this.xfers_complete[md5] = {
              blob: p1,
              start: 0,
              entry: entry,
              writer: writer
            };
            return cb_md5(md5, event === 'success');
          }
        });
      };
      IsErr = function(err, who) {
        if (err === null) {
          return false;
        }
        _log2(who, 'ERROR', err);
        return true;
      };
      return FsGetFileWriter(function(err, entry, writer) {
        if (IsErr(err, f)) {
          return false;
        }
        return StartFile(entry, writer, function(md5, success) {
          if (!success) {
            DoneFile(true, 'not success');
            return;
          }
          success = 'success';
          return FsWriteFile(writer, _this.xfers_complete[md5].blob, function(err) {
            if (err !== null) {
              _log(f, 'FsWriteFile error', md5, err);
              success = err;
              alert('An error has occured writing to local disk. Sorry.');
              _this._Cancel();
              return;
              return _this.cb('WRITE_FS', _this.counters, true, {
                subevent: 'FILE_ERROR',
                handle: md5,
                file: file_rec,
                response: err
              });
            } else {
              _this.cb('WRITE_FS', _this.counters, true, {
                subevent: 'FILE',
                handle: md5,
                file: file_rec,
                response: '(empty)'
              });
              return DoneFile(true, success);
            }
          });
        });
      });
    };

    Zip.prototype._StepWhileXferFiles = function(again) {
      var _this = this;
      if (this.counters.files < this.counters.total_files) {
        this._Progress('DOWNLOAD_FILES');
        return setTimeout((function() {
          if (!_this.cancel) {
            return _this._StepWhileXferFiles(again);
          }
        }), 500);
      }
    };

    Zip.prototype._StepAfterXfer = function() {
      return this._StepCalcCrc32();
    };

    Zip.prototype._StepCalcCrc32 = function() {
      var md5;
      this.crc_todo = (function() {
        var _results;
        _results = [];
        for (md5 in this.xfers_complete) {
          _results.push(md5);
        }
        return _results;
      }).call(this);
      return this._doCrc();
    };

    Zip.prototype._doCrc = function() {
      var Blob2Crc32Async, FsGetFile, IsErr, f, md5, rec,
        _this = this;
      f = 'E:Zip._doCrc';
      _log2(f, 'todo', this.crc_todo.length);
      if (this.crc_todo.length === 0) {
        return this._StepAfterCalc32();
      }
      rec = this.xfers_complete[md5 = this.crc_todo.pop()];
      Blob2Crc32Async = function(blob, prev_crc32, cbe) {
        var f2, reader;
        f2 = 'E:Zip._doCrc.Blob2Crc32Async';
        _log2(f2, 'blob.size', blob.size);
        reader = new FileReader();
        reader.onerror = function(evt) {
          _log2(f2, 'onerror', evt.target.error);
          return cbe(evt.target.error);
        };
        reader.onload = function(evt) {
          var data;
          _log2(f2, 'onload;result.length', evt.target.result.length);
          data = new Uint8Array(evt.target.result);
          _log2(f2, 'onload;data.length', data.length);
          cbe(null, _this.zu.CalcCrc32(data, prev_crc32));
          return _log2(f2, 'BOTTOM-OF-ONLOAD');
        };
        reader.readAsArrayBuffer(blob);
        return _log2(f2, 'BOTTOM');
      };
      FsGetFile = function(entry, cbe) {
        return entry.file(function(file) {
          return cbe(null, file, function(err) {
            return cbe(err);
          });
        });
      };
      IsErr = function(err, who) {
        if (err === null) {
          return false;
        }
        _log2(who, 'ERROR', err);
        return true;
      };
      FsGetFile(rec.entry, function(err, file) {
        if (IsErr(err, f + '>FsGetFile')) {
          return false;
        }
        return Blob2Crc32Async(file.slice(rec.start, rec.start + _this.blob_size), rec.crc32, function(err, crc32) {
          var f3;
          f3 = 'E:Zip._doCrc(Blob2Crc32Async-CALLBACK)';
          _log2(f3, 'err/crc32', err, crc32);
          if (err) {
            alert(err);
          }
          rec.crc32 = crc32;
          rec.start += _this.blob_size;
          if (rec.start < file.size) {
            _this.crc_todo.push(md5);
          }
          setTimeout((function() {
            if (!_this.cancel) {
              return _this._doCrc();
            }
          }), 0);
          return _log2(f3, 'BOTTOM;crc32', crc32);
        });
      });
      return _log2(f, 'BOTTOM');
    };

    Zip.prototype._StepAfterCalc32 = function() {
      return this._StepAssemble();
    };

    Zip.prototype._StepAssemble = function() {
      var f, files, md5, rec, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      f = 'E:Zip._StepAssemble';
      files = [];
      files.push({
        pathname: 'MANIFEST.INF',
        modified: new Date(),
        size: 0
      });
      _ref = this.folder_list;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rec = _ref[_i];
        files.push({
          pathname: rec.path,
          size: 0,
          modified: new Date(Date.parse(rec.modified))
        });
      }
      _ref1 = this.file_list;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        rec = _ref1[_j];
        md5 = this.xfers_complete[rec.md5];
        files.push({
          pathname: rec.path + rec.name,
          size: rec.size,
          entry: md5.entry,
          crc32: md5.crc32,
          modified: new Date(Date.parse(rec.modified))
        });
      }
      return this.zu.Assemble(this.tempFsZipWriter, files, function() {
        return _this.tempFsZipEntry.file(function(file) {
          _this.final_blob = file;
          return _this._StepFinish();
        }, function(err) {
          _log2(f, err);
          return alert('TODO @tempFsZipEntry.file err');
        });
      });
    };

    Zip.prototype._StepFinish = function(after) {
      var msg,
        _this = this;
      if (!after) {
        return setTimeout((function() {
          if (!_this.cancel) {
            return _this._StepFinish(true);
          }
        }), 10);
      }
      this.counters.bytes += 1;
      if (!this._Progress('FINISH', 'blob', {
        blob: this.final_blob,
        zipname: this.zipname
      })) {
        return;
      }
      msg = '(DEFAULT MESSAGE) Downloaded ';
      msg += this.counters.total_folders ? "" + this.counters.folders + " of " + this.counters.total_folders + " folders " : '';
      msg += this.counters.total_files ? ("" + this.counters.files + " of " + this.counters.total_files + " files ") + ("totaling " + this.counters.bytes + " of " + this.counters.total_bytes + " bytes") : '';
      msg += '!';
      return alert(msg);
    };

    Zip.prototype._Progress = function(step_name, subevent, data) {
      var f, new_step, step;
      f = 'E:Zip._Progress:' + step_name;
      step = this.step_types.indexOf(step_name);
      new_step = this.step < step;
      while (this.step < step) {
        if (!this.cb(this.step_types[this.step], this.counters, true)) {
          this._Cancel();
          return false;
        }
        this.step += 1;
      }
      if (!this.cb(this.step_types[this.step], this.counters, false, data)) {
        this._Cancel();
        return false;
      }
      return true;
    };

    return Zip;

  })();

  window.EpicMvc.Extras.Zip = Zip;

  ZipProgress = (function() {

    function ZipProgress(loader, project_id, model_id) {
      this.loader = loader;
      this.project_id = project_id;
      this.model_id = model_id;
      this.progress = __bind(this.progress, this);

      this.stopped = false;
      this.model_xfer = window.EpicMvc.Epic.getInstance('Downloads');
    }

    ZipProgress.prototype.Cancel = function() {
      this.loader.Cancel();
      this.stopped = true;
      if (this.model_id) {
        this.model_xfer._remove(this.model_id);
      }
      return delete this.model_id;
    };

    ZipProgress.prototype._stop = function(msg) {
      if (this.stopped) {
        return;
      }
      this.stopped = true;
      if (msg) {
        alert(msg);
      }
      window.EpicMvc.Epic.makeClick(false, 'cancel_progress', {
        id: this.model_id
      }, true);
      return false;
    };

    ZipProgress.prototype.progress = function(step, cnt, last_flag, extra_data) {
      var f, stats;
      f = 'E:ZipProgress.progress';
      if (step !== "DOWNLOAD_FILES" && step !== "ONE_FILE") {
        _log2(f, step, {
          last: last_flag,
          extra_data: extra_data
        });
      }
      switch (step) {
        case 'START':
          if (last_flag) {
            this.model_xfer.downloadProgress(this.model_id, cnt);
            this.stopped = false;
          }
          break;
        case 'CANCEL':
        case 'CANCEL_ABORT':
          return this._stop(step);
        case 'RESPONSE':
          if (extra_data.subevent === 'FILE' || extra_data.subevent === 'FILE_ERROR') {
            this.model_xfer.fileResponse(this.model_id, extra_data.handle, $.extend({}, extra_data.response));
          }
      }
      switch (step) {
        case 'ONE_FILE':
          this.model_xfer.fileProgress(this.model_id, extra_data.handle, $.extend({}, extra_data, {
            name: extra_data.file.name
          }));
          break;
        default:
          if (step === 'FINISH' || step.match(/^(DOWNLOAD|COUNT)_/)) {
            stats = $.extend({}, cnt, {
              step: step,
              last: (last_flag ? 'yes' : '')
            });
            this.model_xfer.downloadProgress(this.model_id, stats);
          }
      }
      if (step === 'FINISH' && extra_data) {
        this.do_click(window.URL.createObjectURL(extra_data.blob), extra_data.zipname);
      }
      return step !== 'FINISH';
    };

    ZipProgress.prototype.do_click = function(url, filename) {
      var event, link;
      link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', filename);
      event = document.createEvent('MouseEvents');
      event.initMouseEvent('click', true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
      return link.dispatchEvent(event);
    };

    return ZipProgress;

  })();

  window.EpicMvc.Extras.ZipProgress = ZipProgress;

}).call(this);
